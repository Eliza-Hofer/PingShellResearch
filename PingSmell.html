<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Eliza Hofer">
    <meta name="description" content="PingSmell: Sniffing and Detecting Data Smuggled Over Empty Pings">
    <meta name="keywords" content="malware, cybersecurity, proof of concept, ICMP, Reverse Shell">
    <title>PingShell: Smuggling Data and Commands Over Empty Pings</title>
    <link rel="stylesheet" href="styles/style2.css">
     <script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "TechArticle",
  "headline": "PingSmell: Sniffing and Detecting Data Smuggled Over Empty Pings",
  "author": [
    {
      "@type": "Person",
      "name": "Eliza Hofer"
    },
    {
      "@type": "SoftwareSourceCode",
      "name": "PingSmell",
      "programmingLanguage": "Python",
      "codeRepository": "https://github.com/Eliza-Hofer/PingShell-0.2"
    }
  ],
  "datePublished": "2025-04-22",
  "publisher": {
    "@type": "CollegeOrUniversity",
    "name": "University of Kentucky"
  },
  "description": "This page introduces a bot designed to detect data smuggled in binary data from alternating pings.This bot is still in development and will get better with more functionality",
  "url": "https://eliza-hofer.github.io/PingShellResearch/",
  "keywords": ["cybersecurity", "reverse shell", "ICMP", "ping timing", "research", "Malware Detection"]
}
</script>

</head>
<body>
<div>
  <nav class="navbar">
	  <label for="menu-toggle" class="nav-title">Liza's Library <span class="arrow">&#9662;</span></label>
    <input type="checkbox" id="menu-toggle" hidden>
    <ul class="nav-links">
      <li><a href="about_author.html">About Author</a></li>
      <li><a href="impact_analysis.html">Pingshell Impact Analysis</a></li>
      <li><a href="index.html">PingShell</a></li>
      <li><a href="PingSmell.html">PingSmell</a></li>
      <li><a href="more_research.html">More Research</a></li>
      <li><a href="contact.html">Contact</a></li>
    </ul>
  </nav>
</div>
	
<header>
        <h1>PingSmell: Detecting Binary Transmissions Hidden in Pings</h1>
</header>
<main>
	<p>PingSmell is a daemon that sniffs pings and checks for binary patterns in alternating addresses. It is still partially in development, at its current stage it can identify most binary patterns before a whole command can be transmitted and display the ASCII of the binary pattern. In the future I will add features to automatically block addresses when suspicious pings are detected. This bot should allow administrators to be able to ping their servers while still protecting them from a potential ping shell. </p>
	<pre><code>
def find_ip_pairs(ping_log):
    """Find IPs that frequently alternate pings, ignoring noise"""
    if len(ping_log) < 6:
        return []

    # Count frequency of alternations
    alt_counts = Counter()
    ip_set = set(ip for _, ip in ping_log)

    for ip1, ip2 in itertools.combinations(ip_set, 2):
        filtered = [(t, ip) for t, ip in ping_log if ip == ip1 or ip == ip2]
        ips = [ip for _, ip in filtered]

        count = 0
        for i in range(len(ips) - 3):
            seq = ips[i:i+4]
            if seq[0] == seq[2] and seq[1] == seq[3] and seq[0] != seq[1]:
                count += 1
        if count > 0:
            alt_counts[(ip1, ip2)] = count

    return alt_counts.most_common(2)  # top pairs

	</pre></code>
	<p> This function checks logged IP addresses for pairs that have alternating sequences of packets that alternate in potential binary patterns.  This helps us identify potential IP address pairs that could be transmitting data in alternating pings.</p>
	<pre><code>
def analyze_binary_stream(ip1, ip2):
    """Turn filtered ping pattern into binary string"""
    bits = ''
    prev_time = None
    relevant_pings = [(t, ip) for t, ip in ping_log if ip in {ip1, ip2}]

    for t, ip in relevant_pings:
        bit = '1' if ip == ip1 else '0'
        if prev_time is not None and t - prev_time > MAX_TIME_GAP:
            bits += ' '  
        bits += bit
        prev_time = t

    print(f"[!] Stream between {ip1} (1) and {ip2} (0): {bits}")
    chunks = bits.split()
    for chunk in chunks:
        if len(chunk) >= 8:
            try:
                decoded = ''.join(chr(int(chunk[i:i+8], 2)) for i in range(0, len(chunk), 8))
                print(f"    â†’ Decoded: {decoded}")
            except Exception:
                continue

	</pre></code>
	<p>This is the function that converts the pings from the ping log into binary data then into the ASCII representaton of the data so that it becomes human readable. This can help identify and mitigate transfer of data between pairs of pings. </p>

</main>
</body>
